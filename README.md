# RDT 2.2

我们已经完成RDT2.0，但是RDT2.0有一个致命的缺点：如果ACK/NAK报文出错，发送方无法区分“接收方是否会成功接收”，这可能会导致重复数据或死锁。



## RDT2.1

RDT2.1：引入序号机制来应对ACK/ACK错误。

* 添加序号(0/1)：每个数据包都携带唯一序号，接收方会通过序号来判断是否为重新分组。
* 处理ACK/NAK错误：
  * 如果发送方收到了损坏的ACK/NAK或者超时未响应，则需要重传当前的分组。
  * 接收方如果发现有重复的需要时，直接丢弃数据包并且重发ACK，避免重复提交。



## RDT2.2

RDT2.2：和RDT2.1的功能相同，但仅使用ACK。

* **取消NAK报文**：接收方仅通过ACK确认正确接收的分组，并在ACK中显式标注对应分组的序号（如ACK0、ACK1）。
* 重复的ACK等效于NAK：
  * 如果发送方收到了重复的ACK(比如连续受到ACK0)，视为数据包丢失或出错，此时出发重传机制。（例子：接收方期望收到序号1却受到序号0的重复包，会再次返回ACK0，此时发送方重传序号1的分组）。



RDT2.2相比RDT2.1的优势：简化协议设计，避免NAK传输可能出现的错误，仅依赖ACK和序号实现。



请注意：

RDT 2.1/2.2 协议的“序号”在逻辑上是1位（0或1）；但在实验代码实现中，我们使用一个不断递增的整数 `dataIndex`来“模拟”和“承载”这个逻辑上的0/1序号。

也就是：

发送第一个块，`dataIndex = 0`-> **逻辑序号为 0** -> 根据公式，`seq = 1`。

发送第二个块，`dataIndex = 1`-> **逻辑序号为 1** -> `seq = 101`。

发送第三个块，`dataIndex = 2`-> **逻辑序号为 0** -> `seq = 201`。

发送第四个块，`dataIndex = 3`-> **逻辑序号为 1** -> `seq = 301`
